---
sidebar_label: "Hooks"
sidebar_position: 4
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

import UseStateExample from "@site/src/components/reactExamples/UseStateExample";
import UpdateFormInput from "@site/src/components/reactExamples/UpdateFormInput";
import UpdaterFunction from "@site/src/components/reactExamples/UpdaterFunction";

import UseEffectExample from "@site/src/components/reactExamples/UseEffectExample";
import UpdateDomEvents from "@site/src/components/reactExamples/UpdateDomEvents";
import UpdatingDependancyArray from "@site/src/components/reactExamples/UpdatingDependancyArray";

import UseRefExample from "@site/src/components/reactExamples/UseRefExample";
import UpdatingText from "@site/src/components/reactExamples/UpdatingText";
import CheckIfElementWasClicked from "@site/src/components/reactExamples/CheckIfElementWasClicked";

import UseReducerExample from "@site/src/components/reactExamples/UseReducerExample";
import WithContextExample from "@site/src/components/reactExamples/WithContextExample";

import UseContextExample from "@site/src/components/reactExamples/useContext/UseContextExample";
import UseContextHookExample from "@site/src/components/reactExamples/useContext/UseContextHookExample";

import UseMemoExmaple from "@site/src/components/reactExamples/UseMemoExample";
import FactorialCalculator from "@site/src/components/reactExamples/FactorialCalculator";

# Hooks

## useState

[useState](https://react.dev/reference/react/useState) is a React Hook that lets you add a state variable to your component.

```jsx
import { useState } from "react";

...

const [state, setState] = useState(initialState);
```

### Baisc useState Example

Shows a basic example how a button click can update the state of an component.

```jsx
import { useState } from "react";

export default function UseStateExample() {
  const [count, setCount] = useState(0);

  const increase = () => setCount((c) => c + 1);
  const decrease = () => setCount((c) => c - 1);

  return (
    <>
      <button onClick={decrease}>-</button>
      <p>Count: {count}</p>
      <button onClick={increase}>+</button>
    </>
  );
}
```

<UseStateExample />

### Update form input

By adding a onChange to the field input we can see how the state is updated while we type

```jsx
import { useState } from "react";

export default function UpdateFormInput() {
  const [name, setName] = useState("");

  function handleInput(e) {
    setName(e.target.value);
  }

  return (
    <>
      <input onChange={handleInput} />
      <p>You typed: {name}</p>
    </>
  );
}
```

<UpdateFormInput />

### useState Updater function

When updating state the original state does not change if updated multiple time. Each update will modify the original value. To solve this problem, you may pass an updater function

```jsx
import { useState } from "react";

export default function UpdaterFunction() {
  const [countOne, setCountOne] = useState(0);
  const [countTwo, setCountTwo] = useState(0);

  function normalIncrease() {
    // Notice that the count will only update by one since countOne still
    // has the previous state since the component did not update
    setCountOne(countOne + 1);
    setCountOne(countOne + 1);
  }

  function updaterIncrease() {
    // Here, a => a + 1 is your updater function.
    // It takes the pending state and calculates the next state from it.
    setCountTwo((a) => a + 1);
    setCountTwo((a) => a + 1);
  }

  function increase() {
    normalIncrease();
    updaterIncrease();
  }

  return (
    <>
      <div>
        <button onClick={increase}>+</button>
        <p>Count w/o UpdaterFunctiopn: {countOne}</p>
        <p>Count with UpdaterFunctiopn: {countTwo}</p>
      </div>
    </>
  );
}
```

<UpdaterFunction />

### Creating a useState Custom hook

<Tabs>

<TabItem value="useCounter.js">

```js
import { useState } from "react";

export function useCounter() {
  const [count, setCount] = useState(0);

  const increase = () => setCount((c) => c + 1);
  const decrease = () => setCount((c) => c - 1);

  return { count, increase, decrease };
}
```

</TabItem>

<TabItem value="CustomHook.js" >

```jsx
import { useCounter } from "./useCounter";

export default function UseStateCustomHook() {
  const { count, increase, decrease } = useCounter();

  return (
    <>
      <button onClick={decrease}>-</button>
      <p>{count}</p>
      <button onClick={increase}>+</button>
    </>
  );
}
```

</TabItem >

</Tabs>

## useEffect

[useEffect](https://react.dev/reference/react/useEffect) is a React Hook that lets you synchronize a component with an external system.

```jsx
import { useEffect } from "react";

...

useEffect(setup, dependencies?)
```

### Fetch Remote Data

Fetching data from a remote server and display it when the component mounts

```jsx
import { useState, useEffect } from "react";

import { getUsers } from "../../helpers/fakeServer";

export default function UseEffectExample() {
  const [users, setUsers] = useState([]);

  async function fectUsers() {
    const users = await getUsers();
    setUsers(users);
  }

  useEffect(() => {
    fectUsers();
  }, []); // Dependancy array is empty, so it will only run once

  return (
    <>
      {users.map((user, idx) => (
        <p key={idx}>
          {user.name} - {user.age}
        </p>
      ))}
    </>
  );
}
```

<UseEffectExample />

### Updating Dom Events

useEffect can also be used to update Dom events

```jsx
import { useEffect, useState } from "react";

export default function UpdateDomEvents() {
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });

  function trackeMove(e) {
    setMousePosition({ x: e.clientX, y: e.clientY });
  }

  useEffect(() => {
    window.addEventListener("pointermove", trackeMove);
    return () => window.removeEventListener("pointermove", trackeMove);
  }, []);

  return (
    <div>
      <h1>Mouse Position:</h1>
      <p>x: {mousePosition.x}</p>
      <p>y: {mousePosition.y}</p>
    </div>
  );
}
```

<UpdateDomEvents />

### Update component when a state changes

```jsx
import { useState, useEffect } from "react";

import { getUsers, addUser } from "../../helpers/fakeServer";

export default function UpdatingDependancyArray() {
  const [users, setUsers] = useState([]);
  const [lastAction, setLastAction] = useState(new Date().toISOString());

  async function fetchUsers() {
    const users = await getUsers();
    setUsers(users);
  }

  async function addNewUser() {
    await addUser({ name: "Doe", age: 30 });
    setLastAction(new Date().toISOString());
  }

  useEffect(() => {
    fetchUsers();
    console.log("Run");
  }, [lastAction]);

  return (
    <>
      <h1>Last action at: {lastAction}</h1>
      <button onClick={addNewUser}>Add</button>
      {users.map((user, idx) => (
        <p key={idx}>
          {user.name} - {user.age}
        </p>
      ))}
    </>
  );
}
```

<UpdatingDependancyArray />

### Aborting an Async Function

```jsx
import { useEffect, useState } from "react";

import { getUsers } from "../../helpers/fakeServer";

export default function AbortEffect() {
  const [apiStatus, setApiStatus] = useState("Not Set");

  useEffect(() => {
    const apiController = new AbortController();

    async function getDetails() {
      const users = await getUsers(apiController);
      setApiStatus(users[0].name);
    }

    getDetails();
    return () => apiController.abort();
  }, []);

  return <h1>API Status: {apiStatus}</h1>;
}
```

```js
export async function getUsers(apiController = undefined) {
  const users = await axios.get("/users", { signal: apiController?.signal });
  return users.data.users;
}
```

## useRef

[`useRef`](https://react.dev/reference/react/useRef) is a React Hook that lets you reference a value thatâ€™s not needed for rendering. It can be used to access and interact with DOM elements directly, or to store mutable values that don't trigger re-renders.

```jsx
import { useRef } from "react";

// ...

// highlight-next-line
const ref = useRef(initialValue)
```

### Adding Styles to a Box

This example demonstrates how to use `useRef` to directly manipulate the DOM, in this case, adding and removing CSS classes to an element.

<Tabs>

<TabItem value="UseRefExample.jsx">

```jsx
import { useRef } from "react";

import styles from "./ref.module.css";

export default function RefExample() {
  // highlight-next-line
  const redBox = useRef();

  function handleClick() {
    // highlight-next-line
    redBox.current.className = redBox.current.className + " " + styles.spin;
    // highlight-next-line
    redBox.current.textContent = "Spinning";

    setTimeout(() => {
      // highlight-next-line
      redBox.current.textContent = "Stable";
      // highlight-next-line
      redBox.current.className = `${styles.box} ${styles.red}`;
    }, 5500);
  }

  return (
    <>
      <div>
        <button onClick={handleClick}>Red</button>
      </div>
      <div>
        {/* highlight-next-line */}
        <div ref={redBox} className={`${styles.box} ${styles.red}`}>
          Stable
        </div>
      </div>
    </>
  );
}
```

</TabItem>

<TabItem value="ref.module.css">

```css
.box {
  width: 250px;
  height: 250px;
  border: 1px black solid;
  margin: auto;
  margin-top: 4em;
}

.red {
  background-color: darkred;
}

.spin {
  transform: rotate(360deg);
  transition: all 5s;
}
```

</TabItem>

</Tabs>

<UseRefExample />

### Updating Element Text

This example shows how `useRef` can be used to update the text content of a paragraph and the value of an input field directly.

```jsx
import { useRef } from "react";

export default function UpdatingText() {
  // highlight-next-line
  const para = useRef();
  // highlight-next-line
  const inp = useRef();

  function updateParagraph() {
    // highlight-next-line
    para.current.textContent = "Button click updated Paragraph";
  }

  function updateInput() {
    // highlight-next-line
    inp.current.value = "Updated";
  }

  return (
    <div>
      <button onClick={updateParagraph}>Update Paragraph</button>
      <button onClick={updateInput}>Update Input</button>
      {/* highlight-next-line */}
      <p ref={para}>Paragraph</p>
      {/* highlight-next-line */}
      <input ref={inp} placeholder="Type Something" />
    </div>
  );
}
```

<UpdatingText />

### How to Check if an Element Was Clicked

This example demonstrates how to use `useRef` in conjunction with event listeners to determine if a click occurred inside or outside a specific element.

```jsx
import { useEffect, useRef, useState }n from "react";

export default function CheckIfElementWasClicked() {
  // highlight-next-line
  const ref = useRef();
  const [lastClick, setLastClick] = useState();

  function handleClick(e) {
    // highlight-next-line
    if (ref.current && ref.current.contains(e.target)) {
      setLastClick("Clicked inside div");
    } else {
      setLastClick("Clicked outside div");
    }
  }

  // highlight-next-line
  useEffect(() => {
    // highlight-next-line
    document.addEventListener("click", handleClick);
    // highlight-next-line
    return () => document.removeEventListener("click", handleClick);
  });

  return (
    <>
      <h1>Area Clicked: {lastClick}</h1>
      <div
        style={{ width: "600px", height: "600px", backgroundColor: "darkred" }}
      >
        {/* highlight-next-line */}
        <div
          style={{ width: "300px", height: "300px", backgroundColor: "orange" }}
          ref={ref}
        >
          Inner Div
        </div>
      </div>
    </>
  );
}
```

<CheckIfElementWasClicked />

## useReducer

[`useReducer`](https://react.dev/reference/react/useReducer) is a React Hook that lets you manage state with a reducer function. It's an alternative to `useState` for more complex state logic, especially when the next state depends on the previous one or when you have multiple sub-values.

```jsx
import { useReducer } from "react";

// ...

// highlight-next-line
const [state, dispatch] = useReducer(reducer, initialState, init?);
```

### Basic Usage

This example demonstrates a simple counter using `useReducer`.

```jsx
import { useReducer } from "react";

const initialState = {
  balance: 0,
  loan: 0,
};

function reducerFn(state, action) {
  switch (action.type) {
    case "deposit":
      // highlight-next-line
      return { ...state, balance: state.balance + action.payload };

    case "withdraw":
      // highlight-next-line
      return { ...state, balance: state.balance - action.payload };

    case "takeLoan": {
      const loanAmount = action.payload;
      // highlight-next-line
      return {
        ...state,
        balance: state.balance + loanAmount,
        loan: state.loan + loanAmount,
      };
    }

    case "payLoan":
      // highlight-next-line
      return { ...state, loan: 0, balance: state.balance - state.loan };

    default:
      throw new Error("'Unknown action: " + action.type);
  }
}

export default function UserReducerExample() {
  // highlight-next-line
  const [state, dispatch] = useReducer(reducerFn, initialState);
  const { balance, loan } = state;

  // highlight-next-line
  const makeDeposit = () => dispatch({ type: "deposit", payload: 50 });
  // highlight-next-line
  const withdraw = () => dispatch({ type: "withdraw", payload: 30 });
  // highlight-next-line
  const takeLoan = () => dispatch({ type: "takeLoan", payload: 100 });
  // highlight-next-line
  const payLoan = () => dispatch({ type: "payLoan" });

  return (
    <div>
      <div style={{ display: "flex", gap: "3em" }}>
        <span>Balance: $ {balance}</span>
        <span>Outstanding loan: $ {loan}</span>
      </div>
      <div style={{ display: "flex", gap: "3em" }}>
        <button onClick={makeDeposit}>Deposit $50</button>
        <button onClick={withdraw}>Withdraw $30</button>
        <button onClick={takeLoan}>Take $100 loan</button>
        <button onClick={payLoan}>Repay loan</button>
      </div>
    </div>
  );
}
```

<UseReducerExample />

### Adding `useReducer` to a Context for Global Management

`useReducer` can be combined with `useContext` to create a powerful global state management solution, similar to Redux but built with React's native hooks. This pattern is especially useful for complex application state that needs to be shared across multiple components without prop drilling.

The examples below demonstrate complete implementations in both JavaScript and TypeScript. This approach provides predictable state updates through actions while maintaining excellent developer experience.

<Tabs>

<TabItem value="javascript" label="JavaScript">

<Tabs>

<TabItem value="userReducer.js">

Create and export the reducer function and initial state. This will be used by the context provider to allow all components to access the state and dispatch function.

```js
const initialState = {
  name: "",
  age: 0,
};

// highlight-next-line
function userReducerFn(state, action) {
  switch (action.type) {
    case "updateName":
      return { ...state, name: action.payload };

    case "updateAge":
      return { ...state, age: state.age + 1 };

    default:
      throw new Error("Unknown action: " + action.type);
  }
}

// Export the initial state and reducer function
// highlight-next-line
export { initialState, userReducerFn };
```

</TabItem>

<TabItem value="UserContextProvider.jsx">

Creates the context provider with reducer variables and functions, providing global access to child components.

```jsx
import { createContext, useReducer } from "react";
import { initialState, userReducerFn } from "./userReducer";

// Export the userContext for use in the custom hook
// highlight-next-line
export const userContext = createContext({});

export default function UserContextProvider({ children }) {
  // highlight-next-line
  const [{ name, age }, dispatch] = useReducer(userReducerFn, initialState);

  // Action creators that wrap dispatch calls
  // highlight-next-line
  const updateName = (name) => dispatch({ type: "updateName", payload: name });
  // highlight-next-line
  const updateAge = () => dispatch({ type: "updateAge" });

  // Provide state and actions to all children
  return (
    // highlight-next-line
    <userContext.Provider value={{ name, age, updateName, updateAge }}>
      {children}
    </userContext.Provider>
  );
}
```

</TabItem>

<TabItem value="useUser.js">

Simplifies context usage and provides error handling for components used outside the provider.

```js
import { useContext } from "react";
import { userContext } from "./UserContextProvider";

// highlight-next-line
export function useUser() {
  // highlight-next-line
  const context = useContext(userContext);

  if (context === undefined) {
    throw new Error("useUser must be used within a UserContextProvider");
  }

  // highlight-next-line
  return context;
}
```

</TabItem>

<TabItem value="WithContextExample.jsx">

Shows how multiple components can access and modify the shared state without prop drilling.

```jsx
import UserContextProvider from "./UserContextProvider";
import { useUser } from "./useUser";

export default function WithContextExample() {
  return (
    // highlight-next-line
    <UserContextProvider>
      <UserDetails />
      <UserEdits />
    </UserContextProvider>
  );
}

function UserDetails() {
  // highlight-next-line
  const { name, age } = useUser();

  return (
    <div style={{ display: "flex", gap: "2em", marginBottom: "1em" }}>
      <span>Name: {name || "Not set"}</span>
      <span>Age: {age}</span>
    </div>
  );
}

function UserEdits() {
  // highlight-next-line
  const { updateName, updateAge } = useUser();

  // highlight-next-line
  const updateNameHandler = (e) => updateName(e.target.value);

  return (
    <div style={{ display: "flex", gap: "1em" }}>
      <input 
        onChange={updateNameHandler} 
        placeholder="Enter name"
      />
      <button onClick={updateAge}>Increment Age</button>
    </div>
  );
}
```

</TabItem>

</Tabs>

</TabItem>

<TabItem value="typescript" label="TypeScript">

<Tabs>

<TabItem value="userReducer.ts">

Define types for state, actions, and the reducer function. This provides excellent IntelliSense and catches errors at compile time.

```ts
// Define the shape of our user state
export interface UserState {
  name: string;
  age: number;
}

// Define all possible actions using discriminated unions
export type UserAction = 
  | { type: "updateName"; payload: string }
  | { type: "updateAge" };

// Initial state with proper typing
export const initialState: UserState = {
  name: "",
  age: 0,
};

// highlight-next-line
export function userReducerFn(state: UserState, action: UserAction): UserState {
  switch (action.type) {
    case "updateName":
      // highlight-next-line
      return { ...state, name: action.payload };

    case "updateAge":
      // highlight-next-line
      return { ...state, age: state.age + 1 };

    default:
      // TypeScript ensures this is exhaustive
      return state;
  }
}
```

</TabItem>

<TabItem value="UserContextProvider.tsx">

Creates a strongly-typed context that provides both state values and action dispatchers to child components.

```tsx
import { createContext, useReducer, ReactNode } from "react";
import { UserState, UserAction, initialState, userReducerFn } from "./userReducer";

// Define the context value type
interface UserContextType {
  name: string;
  age: number;
  updateName: (name: string) => void;
  updateAge: () => void;
}

// Create context with proper typing
// highlight-next-line
export const userContext = createContext<UserContextType | undefined>(undefined);

interface UserContextProviderProps {
  children: ReactNode;
}

export default function UserContextProvider({ children }: UserContextProviderProps) {
  // highlight-next-line
  const [{ name, age }, dispatch] = useReducer(userReducerFn, initialState);

  // Action creators with proper typing
  // highlight-next-line
  const updateName = (name: string) => dispatch({ type: "updateName", payload: name });
  // highlight-next-line
  const updateAge = () => dispatch({ type: "updateAge" });

  const contextValue: UserContextType = {
    name,
    age,
    updateName,
    updateAge,
  };

  return (
    // highlight-next-line
    <userContext.Provider value={contextValue}>
      {children}
    </userContext.Provider>
  );
}
```

</TabItem>

<TabItem value="useUser.ts">

Provides type-safe access to the user context with runtime error checking.

```ts
import { useContext } from "react";
import { userContext } from "./UserContextProvider";

// highlight-next-line
export function useUser() {
  // highlight-next-line
  const context = useContext(userContext);

  if (context === undefined) {
    throw new Error("useUser must be used within a UserContextProvider");
  }

  // highlight-next-line
  return context;
}
```

</TabItem>

<TabItem value="WithContextExample.tsx">

Demonstrates how components consume the context using the custom hook, with full type safety.

```tsx
import UserContextProvider from "./UserContextProvider";
import { useUser } from "./useUser";

export default function WithContextExample() {
  return (
    // highlight-next-line
    <UserContextProvider>
      <UserDetails />
      <UserEdits />
    </UserContextProvider>
  );
}

function UserDetails() {
  // highlight-next-line
  const { name, age } = useUser();

  return (
    <div style={{ display: "flex", gap: "2em", marginBottom: "1em" }}>
      <span>Name: {name || "Not set"}</span>
      <span>Age: {age}</span>
    </div>
  );
}

function UserEdits() {
  // highlight-next-line
  const { updateName, updateAge } = useUser();

  // highlight-next-line
  const updateNameHandler = (e: React.ChangeEvent<HTMLInputElement>) => {
    updateName(e.target.value);
  };

  return (
    <div style={{ display: "flex", gap: "1em" }}>
      <input 
        onChange={updateNameHandler} 
        placeholder="Enter name"
      />
      <button onClick={updateAge}>Increment Age</button>
    </div>
  );
}
```

</TabItem>

</Tabs>

</TabItem>

</Tabs>

<WithContextExample />

## useContext

[`useContext`](https://react.dev/reference/react/useContext) is a React Hook that lets you read and subscribe to context from your component. `useContext` can be used for global state management, allowing components to access shared data without prop drilling.

```jsx
import { useContext, createContext } from 'react';

const SomeContext = createContext('default value');
// ...

// highlight-next-line
const value = useContext(SomeContext)
```

### Basic Example

This example demonstrates how to create a context and consume it in child components.

<Tabs>

<TabItem value="UserContextProvider.jsx">

Create a context Component that accepts children. The Provider exposes the values to all child components.

```jsx
import { createContext, useState } from "react";

// highlight-next-line
export const UserContext = createContext();

export default function UserContextProvider({ children }) {
  const [userName, setUsername] = useState("");

  const updateName = (name) => setUsername(name);

  return (
    // highlight-next-line
    <UserContext.Provider value={{ userName, updateName }}>
      {children}
    </UserContext.Provider>
  );
}
```

</TabItem>

<TabItem value="UseContextExample.jsx">

By Wrapping ComponentOne and ComponentTwo with UserContextProvider, they can access the context values.

```jsx
import { useContext } from "react";

import UserContextProvider, { UserContext } from "./UserContextProvider";

export default function UseContextExample() {
  return (
    // highlight-next-line
    <UserContextProvider>
      <ComponentOne />
      <ComponentTwo />
    </UserContextProvider>
  );
}

function ComponentOne() {
  // highlight-next-line
  const { updateName } = useContext(UserContext);

  function updateHandler(e) {
    updateName(e.target.value);
  }

  return (
    <div>
      <p>Create User</p>
      <input onChange={updateHandler} />
    </div>
  );
}

function ComponentTwo() {
  // highlight-next-line
  const { userName } = useContext(UserContext);

  return (
    <div>
      <p>UserName: {userName}</p>
    </div>
  );
}
```

</TabItem>

</Tabs>

<UseContextExample />

### Creating a `useContext` Custom Hook

Creating a custom hook for `useContext` can simplify its usage and add error handling.

<Tabs>

<TabItem value="UserContextProvider.js">

```js
import { createContext, useState } from "react";

// highlight-next-line
export const UserContext = createContext();

export default function UserContextProvider({ children }) {
  const [userName, setUsername] = useState("");

  const updateName = (name) => setUsername(name);

  return (
    // highlight-next-line
    <UserContext.Provider value={{ userName, updateName }}>
      {children}
    </UserContext.Provider>
  );
}
```

</TabItem>

<TabItem value="useUser.js">

```js
import { useContext } from "react";

import { UserContext } from "./UserContextProvider";

// highlight-next-line
export function useUser() {
  // highlight-next-line
  const context = useContext(UserContext);

  if (context === undefined) {
    throw new Error("UseUser is used outside the provider");
  }

  // highlight-next-line
  return context;
}
```

</TabItem>

<TabItem value="UseContextExample.jsx">

```jsx
import UserContextProvider from "./UserContextProvider";
import { useUser } from "./useUser";

export default function UseContextExample() {
  return (
    // highlight-next-line
    <UserContextProvider>
      <ComponentOne />
      <ComponentTwo />
    </UserContextProvider>
  );
}

function ComponentOne() {
  // highlight-next-line
  const { updateName } = useUser();

  function updateHandler(e) {
    updateName(e.target.value);
  }

  return (
    <div>
      <p>Create User</p>
      <input onChange={updateHandler} />
    </div>
  );
}

function ComponentTwo() {
  // highlight-next-line
  const { userName } = useUser();

  return (
    <div>
      <p>UserName: {userName}</p>
    </div>
  );
}
```

</TabItem>

</Tabs>

<UseContextHookExample />

## useMemo

[`useMemo`](https://react.dev/reference/react/useMemo) is a React Hook that lets you cache the result of a calculation between re-renders. It helps optimize performance by avoiding expensive recalculations on every render.

```jsx
import { useMemo } from "react";

// ...

// highlight-next-line
const cachedValue = useMemo(calculateValue, dependencies)
```

### Basic Example

This example demonstrates how `useMemo` can prevent a value from being re-calculated unless its dependencies change.

```jsx
import { useState, useMemo } from "react";

export default function UseMEmoExmaple() {
  const [times, setTimes] = useState(0);
  const [force, setForce] = useState(false);

  // highlight-next-line
  const date = useMemo(() => {
    return new Date().toLocaleTimeString();
  }, [force]); // `date` will only update when `force` changes

  return (
    <>
      <p>Times Clicked: {times}</p>
      <button onClick={() => setTimes((t) => t + 1)}>Increase</button>
      <p>Without Memo update: {new Date().toLocaleTimeString()}</p>
      <p>With Memo Update: {date}</p>
      <button onClick={() => setForce((f) => !f)}>Force Rerender</button>
    </>
  );
}
```

<UseMemoExmaple />

### Example: Memoizing a Complex Calculation

This example shows how `useMemo` can be used to optimize performance by memoizing the result of a computationally expensive function (calculating factorial). The factorial is only re-calculated when the input number changes, not on every re-render caused by other state updates.

```jsx
import React, { useState, useMemo } from 'react';

function factorial(n) {
  console.log('Calculating factorial...'); // This will show when the function runs
  if (n < 0) return -1;
  if (n === 0) return 1;
  return n * factorial(n - 1);
}

export default function FactorialCalculator() {
  const [number, setNumber] = useState(1);
  const [incrementor, setIncrementor] = useState(0);

  // highlight-next-line
  const memoizedFactorial = useMemo(() => factorial(number), [number]);

  return (
    <div>
      <h2>Factorial Calculator</h2>
      <input
        type="number"
        value={number}
        onChange={(e) => setNumber(Number(e.target.value))}
      />
      <p>
        Factorial of {number} is: {memoizedFactorial}
      </p>
      <button onClick={() => setIncrementor(incrementor + 1)}>
        Re-render component ({incrementor})
      </button>
      <p>
        This text updates without re-calculating factorial if number is same.
      </p>
    </div>
  );
}
```

<FactorialCalculator />

## useCallback

[`useCallback`](https://react.dev/reference/react/useCallback) is a React Hook that lets you cache a function definition between re-renders. It's useful for performance optimization, especially when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders.

```jsx
import { useCallback } from "react";

// ...

// highlight-next-line
const cachedFn = useCallback(fn, dependencies)
```

### Preventing Unnecessary Re-renders

This example demonstrates how `useCallback` prevents a child component from re-rendering. The `ChildComponent` is wrapped in `React.memo`, which means it will only re-render if its props change.

When the parent's `unrelatedState` changes, the `ParentComponent` re-renders.
- **Without `useCallback`**, a new `handleIncrement` function is created each time, causing the `ChildComponent` to re-render because its `onIncrement` prop is a new function reference.
- **With `useCallback`**, the `handleIncrement` function is memoized. Its reference stays the same across re-renders, so the `ChildComponent` does not re-render.

```jsx
import React, { useState, useCallback } from 'react';

// React.memo prevents the component from re-rendering if its props are the same.
// It does a shallow comparison of the props.
// highlight-next-line
const ChildComponent = React.memo(({ onIncrement }) => {
  return <button onClick={onIncrement}>Increment Count</button>;
});

export default function ParentComponent() {
  const [count, setCount] = useState(0);
  const [unrelatedState, setUnrelatedState] = useState(0);

  // The handleIncrement function is memoized with useCallback.
  // It will only be recreated if its dependencies (empty array) change.
  // highlight-next-line
  const handleIncrement = useCallback(() => {
    setCount(c => c + 1);
  }, []);

  return (
    <div>
      <p>Count: {count}</p>
      <ChildComponent onIncrement={handleIncrement} />
      <hr />
      <p>Unrelated State: {unrelatedState}</p>
      <button onClick={() => setUnrelatedState(n => n + 1)}>
        Change Unrelated State
      </button>
    </div>
  );
}
```

