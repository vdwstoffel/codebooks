---
sidebar_label: "Components"
sidebar_position: 3
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

import BasicComponent from "@site/src/components/reactExamples/components/BasicComponent";
import PassingProps from "@site/src/components/reactExamples/components/PassingProps";
import ChildComponents from "@site/src/components/reactExamples/components/ChildComponents";
import LiftingState from "@site/src/components/reactExamples/components/LiftingState";
import CounterApp from "@site/src/components/reactExamples/components/CounterApp";
import Counter from "@site/src/components/reactExamples/components/Counter";

# Components

## Basic Component

Components are the building blocks of React applications. They are independent and reusable pieces of UI. A basic functional component is a JavaScript function that returns JSX.

```jsx
import BrowserWindow from "@site/src/components/BrowserWindow/BrowserWindow";

export default function BasicComponent() {
  return (
    // highlight-next-line
    <BrowserWindow>
      <h1>This is a basic component</h1>
    </BrowserWindow>
  );
}
```

<BasicComponent />

## Passing Props

Components can receive data through props (short for properties). Props are passed to components using attributes, similar to HTML attributes.

```jsx
export default function PassingProps() {
  return (
    <>
      {/* highlight-next-line */}
      <User name="John" age={42} />
      {/* highlight-next-line */}
      <User name="Strong" age={31} />
    </>
  );
}

function User({ name, age }) {
  return (
    <p>
      This is {name}, who is {age}
    </p>
  );
}
```

<PassingProps />

## Child Components

Components can render other components as their children. The `children` prop allows you to pass components or elements directly into another component.

```jsx
export default function ChildComponents() {
  return (
    // highlight-next-line
    <Container>
      <button>Click Me!</button>
    </Container>
  );
}

function Container({ children }) {
  return (
    <div style={{ backgroundColor: "darkred", padding: "3em" }}>{children}</div>
  );
}
```

<ChildComponents />

## React Composition

React's composition model allows you to build complex components from simpler ones. Instead of prop drilling (passing props through many layers of components), you can use composition to pass components as children or props.

```jsx
import React from "react";

function ParentComponent({ children }) {
  return <div className="parent-component">{children}</div>;
}

function ChildComponent({ message }) {
  return <div className="child-component">{message}</div>;
}

function App() {
  return (
    // highlight-next-line
    <ParentComponent>
      {/* highlight-next-line */}
      <ChildComponent message="Hello" />
    </ParentComponent>
  );
}
```

## Lifting State Up

Lifting state up in React refers to the process of moving state from child components up to a common ancestor component. This allows multiple components to share and manipulate the same state, which is often necessary when those components need to stay in sync.

```jsx
import { useState } from "react";

export default function LiftingState() {
  // highlight-next-line
  const [count, setCount] = useState(0);

  return (
    <>
      {/* highlight-next-line */}
      <ChildA count={count} />
      {/* highlight-next-line */}
      <ChildB setCount={setCount} />
    </>
  );
}

function ChildA({ count }) {
  return <div>Count: {count}</div>;
}

function ChildB({ setCount }) {
  return (
    <button onClick={() => setCount((count) => count + 1)}>Increment</button>
  );
}
```

<LiftingState />

## React Fragments

React fragments let you group a list of children without adding extra nodes to the DOM. This can be useful when you need to return multiple elements from a component but don't want to wrap them in an unnecessary `div`.

```jsx
export default function Example() {
  return (
    // highlight-next-line
    <>
      <ChildA />
      <ChildB />
    </>
  );
}
```

## Compound Component Pattern

The Compound Component pattern provides a flexible and reusable way to build components that work together implicitly. It allows you to create a set of components that share state and logic, without explicitly passing props down through every level of the component tree.

<Tabs>

<TabItem value="Counter.jsx">

```jsx
import { createContext, useContext, useState }n from "react";

// 1. Create Context
// highlight-next-line
const CounterContext = createContext();

// 2. Create Parent component
export default function Counter({ children }) {
  const [count, setCount] = useState(0);
  const increment = () => setCount((c) => c + 1);
  const decrement = () => setCount((c) => c - 1);

  return (
    // highlight-next-line
    <CounterContext.Provider value={{ count, increment, decrement }}>
      {children}
    </CounterContext.Provider>
  );
}

// 3. Create helper child components
function Label({ label }) {
  return <h1>{label}</h1>;
}

function Count() {
  // highlight-next-line
  const { count } = useContext(CounterContext);
  return <span>{count}</span>;
}

function Increase({ icon = "+" }) {
  // highlight-next-line
  const { increment } = useContext(CounterContext);
  return <button onClick={increment}>{icon}</button>;
}

function Decrement({ icon = "-" }) {
  // highlight-next-line
  const { decrement } = useContext(CounterContext);
  return <button onClick={decrement}>{icon}</button>;
}

// 4. Add child compoents as properties
// highlight-next-line
Counter.Label = Label;
// highlight-next-line
Counter.Count = Count;
// highlight-next-line
Counter.Increase = Increase;
// highlight-next-line
Counter.Decrement = Decrement;
```

</TabItem>

<TabItem value="App.jsx">

```jsx
import Counter from "./Counter";

export default function CounterApp() {
  return (
    // highlight-next-line
    <Counter>
      <Counter.Label label="Counter Example" />
      <Counter.Increase icon="-" />
      <Counter.Count />
      <Counter.Increase icon="+" />
    </Counter>
  );
}
```

</TabItem>

</Tabs>

<CounterApp />

