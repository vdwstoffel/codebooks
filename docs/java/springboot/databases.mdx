---
sidebar_label: "Databases"
sidebar_position: 4
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Databases

## Setting up a Database

```xml title="pom.xml"
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<!-- MYSQL -->
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <scope>runtime</scope>
</dependency>

<!-- POSTGRESQL -->
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <scope>runtime</scope>
</dependency>
```

```bash
.
cruddemo
├── CruddemoApplication.java
├── dao
│   ├── EmployeeDAOImpl.java
│   └── EmployeeDAO.java
├── entity
│   └── Employee.java
├── rest
│   └── EmployeeRestController.java
└── service
    ├── EmployeeServiceImpl.java
    └── EmployeeService.java
```

<Tabs>

<TabItem value="Add DB info">

```properties title="application.properties"
spring.datasource.url=jdbc:mysql://192.168.129.15:9998/database_name
spring.datasource.username=root
spring.datasource.password=demo
```

</TabItem>

<TabItem value="Entity Class">

- `@Entity` annotation is used to define a JPA entity.
- `@Table` annotation is used to define the table name.
- `@Id` annotation is used to define the primary key.
- `@GeneratedValue` annotation is used to define the generation strategy for the primary key.
- `@Column` annotation is used to define the column name.

```java title="Employee.java"
package com.example.cruddemo.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

// Marks this class as a JPA entity and maps it to the database table "employee"
@Entity
@Table(name = "employee")
public class Employee {

    // Specifies the primary key for this entity
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Auto-generates the ID using the database's identity column
    @Column(name = "id") // Maps this field to the "id" column in the table
    private int id;

    // Maps the "firstName" field to the "first_name" column in the table
    @Column(name = "first_name")
    private String firstName;

    // Maps the "lastName" field to the "last_name" column in the table
    @Column(name = "last_name")
    private String lastName;

    // Maps the "email" field to the "email" column in the table
    @Column(name = "email")
    private String email;

    // Default no-argument constructor needed by JPA
    public Employee() {
    }

    // Constructor for initializing an Employee object with specified values
    public Employee(String firstName, String lastName, String email) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.email = email;
    }

    // getters and setters (required)
    ...

    @Override
    public String toString() {
        return "SomeString"
    }
}
```

</TabItem>

<TabItem value="DAO">

The DAO (Data Access Object) is a design pattern in Java used to manage the interaction between the application and the database

- `@Repository`: This annotation identifies the class as a DAO (Data Access Object). It allows Spring to detect it as a bean and manage it as part of the application context.
- EntityManager: EntityManager is a JPA interface that handles database operations. It is injected into this DAO to perform queries and manage entities.
- Constructor Injection: The EmployeeDAOImpl class uses constructor injection to receive an instance of EntityManager.
- `@Autowired` annotation ensures that Spring injects the required dependency automatically.

```java title="EmployeeDAO.java"
package com.example.cruddemo.dao;

import java.util.List;

import com.example.cruddemo.entity.Employee;

public interface EmployeeDAO {
    List<Employee> findAll();
    Employee save(Employee employee);
}
```

```java title="EmployeeDAOImpl.java"
package com.example.cruddemo.dao;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;

import com.example.cruddemo.entity.Employee;

import jakarta.persistence.EntityManager;
import jakarta.persistence.TypedQuery;

@Repository // Marks this class as a Spring-managed bean specifically for data access logic
public class EmployeeDAOImpl implements EmployeeDAO {

    private EntityManager entityManager; // EntityManager is used to interact with the persistence context and the database

    // Constructor injection of the EntityManager dependency
    @Autowired // Automatically injects an EntityManager bean into this class
    public EmployeeDAOImpl(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    @Override
    public List<Employee> findAll() {
        // Create a JPQL query to fetch all Employee entities from the database
        // "FROM Employee" refers to the Employee entity, not the database table
        TypedQuery<Employee> query = entityManager.createQuery("FROM Employee", Employee.class);

        // Execute the query and return the list of Employee objects
        return query.getResultList();
    }

    @Override
    public Employee save(Employee employee) {
        return entityManager.merge(employee);
    }
}
```

</TabItem>

<TabItem value="Service Layer">

The service layer in a Spring Boot application is responsible for implementing the business logic of the application. It acts as a bridge between the controller layer (which handles HTTP requests) and the DAO/repository layer (which interacts with the database).

- `@Service`: Specifies that this class contains business logic and makes it discoverable as a Spring-managed service component.

- `@Transactional`: Ensures the save() method is wrapped in a database transaction to maintain data consistency.

- EmployeeDAO: The DAO (Data Access Object) is injected into the service layer to handle database operations. This approach ensures separation of concerns.
- Constructor Injection with `@Autowired`: Spring automatically injects the required dependency (EmployeeDAO) into this service class at runtime. Constructor injection is preferred for mandatory dependencies as it makes them explicit.

```java title="EmployeeService.java"
package com.example.cruddemo.service;

import java.util.List;

import com.example.cruddemo.entity.Employee;

public interface EmployeeService {
    List<Employee> findAll();
    Employee save(Employee employee);
}
```

```java title="EmployeeServiceImpl.java"
package com.example.cruddemo.service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.example.cruddemo.dao.EmployeeDAO;
import com.example.cruddemo.entity.Employee;

@Service // Marks this class as a Spring service, making it a Spring-managed bean for business logic
public class EmployeeServiceImpl implements EmployeeService {

    private EmployeeDAO employeeDAO; // DAO layer for database access related to employees

    // Constructor-based dependency injection for the DAO layer
    @Autowired // Automatically injects an EmployeeDAO implementation
    public EmployeeServiceImpl(EmployeeDAO employeeDAO) {
        this.employeeDAO = employeeDAO;
    }

    @Override
    public List<Employee> findAll() {
        // Delegates the task of fetching all employees to the DAO layer
        return employeeDAO.findAll();
    }

    @Override
    @Transactional // Ensures the save operation is executed within a transactional context
    public Employee save(Employee employee) {
        // Delegates the task of saving an employee to the DAO layer
        return employeeDAO.save(employee);
    }
}

```

</TabItem>

<TabItem value="Controller">

- `@RestController`: Indicates that this class will handle RESTful web requests. It combines @Controller and @ResponseBody, meaning the methods will return data (e.g., JSON) directly to the client.

- `@RequestMapping`: Sets a common URL prefix (/api) for all endpoints in the controller.

- Constructor Injection: The service layer (EmployeeService) is injected into the controller to access business logic and delegate tasks like fetching data.

- `@GetMapping`: Specifies that this method handles GET requests for the endpoint /api/employees.

```java title="EmployeeRestController.java"
package com.example.cruddemo.rest;

import java.util.List;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.example.cruddemo.entity.Employee;
import com.example.cruddemo.service.EmployeeService;

@RestController // Marks this class as a Spring REST controller, enabling it to handle HTTP requests
@RequestMapping("/api") // Sets the base URL for all endpoints in this controller to "/api"
public class EmployeeRestController {

    private EmployeeService employeeService; // Service layer dependency for handling business logic

    // Constructor-based dependency injection for EmployeeService
    public EmployeeRestController(EmployeeService employeeService) {
        this.employeeService = employeeService;
    }

    @GetMapping("/employees") // Maps HTTP GET requests to "/api/employees" to this method
    public List<Employee> findAll() {
        // Delegates the logic for retrieving all employees to the service layer
        return employeeService.findAll();
    }
}
```

</TabItem>

</Tabs>

## Database Configuration

```application.properties title="application.properties"
spring.datasource.url=jdbc:mysql://192.168.129.15:9998/student_tracker
spring.datasource.username=demo
spring.datasource.password=demo
// highlight-next-line
spring.jpa.hibernate.ddl-auto=update // Don't use in production
```

| Property    | Description                                   |
| ----------- | --------------------------------------------- |
| none        | No action is taken.                           |
| create      | Creates the schema, destroying previous data. |
| create-drop | Drops the schema at the end of the session.   |
| update      | Updates the schema. No data is lost           |
| validate    | Validates the schema.                         |

## CRUD

### Create

```java
@Override
@Transactional
public void createStudent(Student theStudent) {
    entityManager.persist(theStudent);
}
```

### Read

- Read One

```java
@Override
public Student getStudent(int studentId) {
    return entityManager.find(Student.class, studentId);
}
```

- Read All

JPQL (Java Persistence Query Language) is used to query the database. In the below example Student refers to the entity class name, not the table name. Similarly, the field names refer to the entity class field names not the column names.

```java
import jakarta.persistence.TypedQuery;
import java.util.List;

@Override
public List<Student> findAll() {
    TypedQuery<Student> theQuery = entityManager.createQuery("FROM Student", Student.class);
    return theQuery.getResultList();
}
```

### Update

```java
@Override
@Transactional
public void updateStudent(int studentId, String newStudentName) {
    Student student = this.findById(studentId); // some find by id function
    student.setFirstName(newStudentName);	// Method taken from the Student entity/class
    entityManager.merge(student);
    System.out.println("Updated student " + student);
}
```

### Delete

```java
@Override
@Transactional
public void deleteStudent(int studentId) {
    Student student = this.findById(studentId);
    entityManager.remove(student);
}
```

## Using JPQL

JQPL (Java Persistence Query Language) is used to query the database. It is similar to SQL but uses entity class names and field names instead of table names and column names.

```SQl
SELECT * FROM student WHERE last_name='Doe';
```

```java
TypedQuery<Student> theQuery = entityManager.createQuery("FROM Student s WHERE s.lastName='Doe'", Student.class);
theQuery.getResultList();
```

```sql
DELETE FROM student;
```

```java
entityManager.createQuery("DELETE FROM Student").executeUpdate();
```

### Injecting query parameters

```java title="StudentDAO.java"
public List<Student> getStudents(String lastName);
```

The `:lastName` is a named parameter that will be replaced by the value passed to the `setParameter` method.

```java title="StudentDAOImpl.java"
@Override
public List<Student> getStudents(String lastName) {
    TypedQuery<Student> theQuery = entityManager.createQuery("FROM Student s WHERE s.lastName=:lastName", Student.class);
    theQuery.setParameter("lastName", lastName);
    return theQuery.getResultList();
}
```

## Foreig Keys

- @OneToMany: This establishes a one-to-many relationship, meaning one User entity is associated with multiple Expense entities.

- mappedBy = "user": This specifies the field in the Expense entity that defines the relationship. In this case, user is the field in the Expense entity annotated with @ManyToOne. It tells JPA that the User side is the "inverse" side of the relationship, and the Expense entity owns the relationship (i.e., holds the foreign key).

- cascade = CascadeType.ALL: This enables cascading operations. When a User entity is persisted, updated, or deleted, the same operations will automatically be applied to the associated Expense entities. For example:
When you save a User, all its Expense entries are saved automatically.
If you delete a User, all its Expense entries are deleted as well.

- orphanRemoval = true: This ensures that if an Expense entry is removed from the User's expenses list, it is also deleted from the database. It's useful for maintaining database integrity—no "orphaned" records (i.e., records not referenced by any parent entity) are left behind.

<Tabs>

<TabItem value="User">

```java
import jakarta.persistence.*;
import java.util.List;

@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Auto-increment ID
    private Long id;

    private String name;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true) // One-to-Many relationship
    private List<Expense> expenses;

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public List<Expense> getExpenses() {
        return expenses;
    }

    public void setExpenses(List<Expense> expenses) {
        this.expenses = expenses;
    }
}
```

</TabItem>

<TabItem value="Expense">

```java
import jakarta.persistence.*;

@Entity
public class Expense {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Auto-increment ID
    private Long id;

    private String description;
    private Double amount;

    @ManyToOne // Many-to-One relationship with User
    @JoinColumn(name = "user_id") // Foreign key in Expense table
    private User user;

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public Double getAmount() {
        return amount;
    }

    public void setAmount(Double amount) {
        this.amount = amount;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }
}

```

</TabItem>

<TabItem value="Service">

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class ExpenseService {
    @Autowired
    private UserRepository userRepository;

    @Autowired
    private ExpenseRepository expenseRepository;

    // Method to create and save an Expense
    public Expense createExpense(Long userId, String description, Double amount) {
        // Fetch the User entity by its ID
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        // Create a new Expense instance
        Expense expense = new Expense();
        expense.setDescription(description);
        expense.setAmount(amount);
        expense.setUser(user); // Set the foreign key relationship

        // Save the Expense in the database
        return expenseRepository.save(expense);
    }
}
```
</TabItem>

</Tabs>

## Spring Data JPA

Spring Data JPA is a module of the Spring Framework that simplifies working with databases in Java applications. It builds on JPA (Java Persistence API) and provides powerful tools to perform common database operations, such as saving, retrieving, and updating data, with minimal boilerplate code

<Tabs>

<TabItem value="Entity Class">

- `@Entity` annotation is used to define a JPA entity.
- `@Table` annotation is used to define the table name.
- `@Id` annotation is used to define the primary key.
- `@GeneratedValue` annotation is used to define the generation strategy for the primary key.
- `@Column` annotation is used to define the column name.

```java title="Employee.java"
package com.example.cruddemo.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

// Marks this class as a JPA entity and maps it to the database table "employee"
@Entity
@Table(name = "employee")
public class Employee {

    // Specifies the primary key for this entity
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Auto-generates the ID using the database's identity column
    @Column(name = "id") // Maps this field to the "id" column in the table
    private int id;

    // Maps the "firstName" field to the "first_name" column in the table
    @Column(name = "first_name")
    private String firstName;

    // Maps the "lastName" field to the "last_name" column in the table
    @Column(name = "last_name")
    private String lastName;

    // Maps the "email" field to the "email" column in the table
    @Column(name = "email")
    private String email;

    // Default no-argument constructor needed by JPA
    public Employee() {
    }

    // Constructor for initializing an Employee object with specified values
    public Employee(String firstName, String lastName, String email) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.email = email;
    }

    // getters and setters (required)
    ...

    @Override
    public String toString() {
        return "SomeString"
    }
}
```

</TabItem>

<TabItem value="Repository">

In Spring Data JPA, a repository is an interface that handles the interaction with the database. It provides built-in methods for common tasks like saving, retrieving, updating, and deleting data, so you don't need to write boilerplate code

```java title="EmployeeDAOImpl.java"
package com.example.cruddemo.dao;

import org.springframework.data.jpa.repository.JpaRepository;

import com.example.cruddemo.entity.Employee;

public interface EmployeeRepository extends JpaRepository<Employee, Integer>  {
    // basic crud operation extends from the JPA Repository
}
```

</TabItem>

<TabItem value="Service Layer">

The service layer in a Spring Boot application is responsible for implementing the business logic of the application. It acts as a bridge between the controller layer (which handles HTTP requests) and the DAO/repository layer (which interacts with the database).

- `@Service`: Specifies that this class contains business logic and makes it discoverable as a Spring-managed service component.

- EmployeeDAO: The DAO (Data Access Object) is injected into the service layer to handle database operations. This approach ensures separation of concerns.
- Constructor Injection with `@Autowired`: Spring automatically injects the required dependency (EmployeeDAO) into this service class at runtime. Constructor injection is preferred for mandatory dependencies as it makes them explicit.

```java title="EmployeeService.java"
package com.example.cruddemo.service;

import java.util.List;

import com.example.cruddemo.entity.Employee;

public interface EmployeeService {
    List<Employee> findAll();
    Employee findById(int theId);
    Employee save(Employee thEmployee);
    void deleteById(int theId);
}
```

```java title="EmployeeServiceImpl.java"
package com.example.cruddemo.service;

import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;


import com.example.cruddemo.dao.EmployeeRepository;
import com.example.cruddemo.entity.Employee;


@Service
public class EmployeeServiceImpl implements EmployeeService {

    private EmployeeRepository employeeRepository;

    @Autowired
    public EmployeeServiceImpl(EmployeeRepository employeeRepository) {
        this.employeeRepository = employeeRepository;
    }

    @Override
    public List<Employee> findAll() {
        return employeeRepository.findAll();
    };

    @Override
    public Employee findById(int theId) {

        Optional<Employee> result = employeeRepository.findById(theId);
        Employee employee = null;

        if (result.isPresent()) {
            employee = result.get();
        } else {
            throw new RuntimeException("Did not find employee id");
        }

        return employee;
    }

    @Override
    public Employee save(Employee thEmployee) {
        return employeeRepository.save(thEmployee);
    }

    @Override
    public void deleteById(int theId) {
        employeeRepository.deleteById(theId);
    }
}
```

</TabItem>

<TabItem value="Controller">

- `@RestController`: Indicates that this class will handle RESTful web requests. It combines @Controller and @ResponseBody, meaning the methods will return data (e.g., JSON) directly to the client.

- `@RequestMapping`: Sets a common URL prefix (/api) for all endpoints in the controller.

- Constructor Injection: The service layer (EmployeeService) is injected into the controller to access business logic and delegate tasks like fetching data.

- `@GetMapping`: Specifies that this method handles GET requests for the endpoint /api/employees.

```java title="EmployeeRestController.java"
package com.example.cruddemo.rest;

import java.util.List;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.example.cruddemo.entity.Employee;
import com.example.cruddemo.service.EmployeeService;

@RestController // Marks this class as a Spring REST controller, enabling it to handle HTTP requests
@RequestMapping("/api") // Sets the base URL for all endpoints in this controller to "/api"
public class EmployeeRestController {

    private EmployeeService employeeService; // Service layer dependency for handling business logic

    // Constructor-based dependency injection for EmployeeService
    public EmployeeRestController(EmployeeService employeeService) {
        this.employeeService = employeeService;
    }

    @GetMapping("/employees") // Maps HTTP GET requests to "/api/employees" to this method
    public List<Employee> findAll() {
        // Delegates the logic for retrieving all employees to the service layer
        return employeeService.findAll();
    }
}
```

</TabItem>

</Tabs>

## Spring Data Rest

Spring Data REST is a Spring module that automatically exposes the repositories you define in Spring Data as RESTful web services. It simplifies the process of building REST APIs by handling the creation of endpoints for CRUD operations, pagination, and sorting out of the box

```bash
cruddemo
├── CruddemoApplication.java
├── dao
│   └── EmployeeRepository.java
├── entity
│   └── Employee.java
```

```xml title="pom.xml"
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-rest</artifactId>
</dependency>
```

<Tabs>

<TabItem value="Entity">

```java title="Employee.java"

package com.example.cruddemo.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

@Entity
@Table(name = "employee")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private int id;

    @Column(name = "first_name")
    private String firstName;

    @Column(name = "last_name")
    private String lastName;

    @Column(name = "email")
    private String email;

    public Employee() {
    };

    public Employee(String firstName, String lastName, String email) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.email = email;
    };

    // getter and setter

    @Override
    public String toString() {
        return "Employee {" +
                "id=" + this.id +
                ", firstName='" + this.firstName + "\'" +
                ", LastName='" + this.lastName + "\'" +
                ", email='" + this.email + "\'" +
                "}";
    }
}
```

</TabItem>
<TabItem value="Repository">

```java title="EmployeeRepositort.java"
package com.example.cruddemo.dao;

import org.springframework.data.jpa.repository.JpaRepository;

import com.example.cruddemo.entity.Employee;

public interface EmployeeRepository extends JpaRepository<Employee, Integer>  {
    // basic crud operation extends from the JPA Repository
}
```

</TabItem>

</Tabs>

- Now go to http://localhost:8080/employees

### Rename resource

```java title="EmployeeRepository"
package com.example.cruddemo.dao;

import org.springframework.data.jpa.repository.JpaRepository;
// highlight-next-line
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

import com.example.cruddemo.entity.Employee;

// highlight-next-line
@RepositoryRestResource(path = "members")
public interface EmployeeRepository extends JpaRepository<Employee, Integer>  {
    // basic crud operation extends from the JPA Repository
}
```

### Changing configs

```properties title="application.properties"
spring.data.rest.default-page-size=3
```

```

```
