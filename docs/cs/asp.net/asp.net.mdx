---
sidebar_label: "ASP.NET"
sidebar_position: 2
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# ASP.NET

## Create a new ASP.NET project

```bash
dotnet new webapi --use-controllers -o MyApi
dotnet add package Microsoft.EntityFrameworkCore.InMemory
```

```bash

├── Controllers
│   └── TodoItemsController.cs
├── Models
│   ├── TodoContext.cs
│   └── TodoItem.cs
├── Program.cs
```

<Tabs>

<TabItem value="TodoItem.cs">

A model is a set of classes that represent the data that the app manages. The model for this app is the TodoItem class.

```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace TodoApi.Models
{
    public class TodoItem // This class represents the data model for a to-do item. The Id property is the unique identifier for the item and is required. The Name property is a string containing the name of the to-do item and is also required. The IsComplete property is a Boolean that represents whether the to-do item has been completed.
    {
        [Key] // The Key attribute specifies that the Id property is the unique identifier for the item.
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)] // The DatabaseGenerated attribute specifies that the Id property will be generated by the database.
        public long Id { get; set; }
        public string Name { get; set; }
        public bool IsComplete { get; set; }
    }
}
```

</TabItem>

<TabItem value="TodoItemDto.cs">

To hide the database-specific properties, you can create a DTO (data transfer object) class for the TodoItem class.

```csharp
namespace TodoApi.Models
{
    public class TodoItemDto
    {
        public string Name { get; set; }
        public bool IsComplete { get; set; }
    }
}
```

</TabItem>

<TabItem value="TodoContext.cs">

The database context is the main class that coordinates Entity Framework functionality for a data model. This class is created by deriving from the Microsoft.EntityFrameworkCore.DbContext class.

```csharp
using Microsoft.EntityFrameworkCore;

namespace TodoApi.Models
{

    public class TodoContext : DbContext // This class represents the database context and derives from DbContext. The database context is used to query and save instances of the entities to the database.
    {
        public TodoContext(DbContextOptions<TodoContext> options) : base(options) // This constructor uses dependency injection to inject the database context (TodoContext) into the controller. The database context is used in each of the CRUD methods in the controller.
        {

        }

        public DbSet<TodoItem> TodoItems { get; set; } = null!; // This property creates a DbSet<T> property for the entity set. In Entity Framework terminology, an entity set typically corresponds to a database table. The name of the DbSet<T> property is used as the table name in the database. In this case, the table name is TodoItems.
    }
}
```

</TabItem>

<TabItem value="TodoItemsController.cs">

```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

using TodoApi.Models;

namespace TodoApi.Controllers
{
    [Route("api/[controller]")] // This attribute specifies the route template [controller] that is replaced by the controller name minus the "Controller" suffix.
    [ApiController] // This attribute indicates that the controller responds to web API requests.
    public class TodoItemController: ControllerBase // ControllerBase is the base class for ASP.NET Core web API controllers.
    {
        private readonly TodoContext _context; // This field contains the database context.

        public TodoItemController(TodoContext context) // This constructor uses ASP.NET Core dependency injection to inject the database context into the controller. The database context is used in each of the CRUD methods in the controller.
        {
            _context = context; // This constructor uses ASP.NET Core dependency injection to inject the database context into the controller. The database context is used in each of the CRUD methods in the controller.
        }

        private bool TodoItemExists(long id)
        {
            return _context.TodoItems.Any(e => e.Id == id); // This method checks if a to-do item exists by ID.
        }

        // GET: api/TodoItems
        [HttpGet] // This attribute specifies an HTTP GET method. The method name is automatically created by convention.
        public async Task<ActionResult<IEnumerable<TodoItem>>> GetTodoItems() // This method returns all to-do items.
        {

            return await _context.TodoItems.ToListAsync(); // This method returns all to-do items.
        }

        // GET: api/TodoItems/5
        [HttpGet("{id}")] // This attribute specifies an HTTP GET method with a route template of "{id}". The method name is automatically created by convention.
        public async Task<ActionResult<TodoItem>> GetTodoItem(long id) // This method returns a specific to-do item.
        {
            var todoItem = await _context.TodoItems.FindAsync(id); // This method finds a to-do item by ID.

            if (todoItem == null) // This method checks if the to-do item is null.
            {
                return NotFound(); // This method returns a 404 status code, which means that the requested resource could not be found.
            }

            return todoItem; // This method returns the to-do item.
        }

        // POST: api/TodoItems
        [HttpPost] // This attribute specifies an HTTP POST method. The method name is automatically created by convention.
        public async Task<ActionResult<TodoItem>> PostTodoItem(TodoItemDto item) // This method adds a to-do item.
        {
            var newItem = new TodoItem
            {
                Name = item.Name,
                IsComplete = item.IsComplete
            };

            _context.TodoItems.Add(newItem); // This method adds a to-do item.
            await _context.SaveChangesAsync(); // This method saves the changes to the database.return CreatedAtAction(nameof(GetTodoItem), new { id = item.Id }, item); // This method returns a 201 status code, which means that the request has been fulfilled and has resulted in one or more new resources being created.
            return Ok("Item Posted");
        }

        // PUT: api/TodoItems/5
        [HttpPut("{id}")] // This attribute specifies an HTTP PUT method with a route template of "{id}". The method name is automatically created by convention.
        public async Task<IActionResult> PutTodoItem(long id, TodoItemDto item) // This method updates a to-do item.
        {
            var todoItem = await _context.TodoItems.FindAsync(id); // This method finds a to-do item by ID.

            if (todoItem == null)
            {
                return NotFound();
            }

            todoItem.Name = item.Name;
            todoItem.IsComplete = item.IsComplete;

            try
            {
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateConcurrencyException) // This catch block catches any DbUpdateConcurrencyException exceptions that are thrown during the save operation.
            {
                if (!TodoItemExists(id))
                {
                    return NotFound();
                }
                else
                {
                    throw;
                }
            }

            return NoContent();
        }

        // DELETE: api/TodoItems/5
        [HttpDelete("{id}")] // This attribute specifies an HTTP DELETE method with a route template of "{id}". The method name is automatically created by convention.
        public async Task<IActionResult> DeleteTodoItem(long id) // This method deletes a to-do item.
        {
            var todoItem = await _context.TodoItems.FindAsync(id); // This method finds a to-do item by ID.

            if (todoItem == null) // This method checks if the to-do item is null.
            {
                return NotFound(); // This method returns a 404 status code, which means that the requested resource could not be found.
            }

            _context.TodoItems.Remove(todoItem); // This method removes the to-do item.
            await _context.SaveChangesAsync(); // This method saves the changes to the database.

            return NoContent(); // This method returns a 204 status code, which means that the server has successfully fulfilled the request and that there is no additional content to send in the response payload body.
        }
    }
}
```

</TabItem>

<TabItem value="Program.cs">

```csharp
using Microsoft.EntityFrameworkCore;
using TodoApi.Models;

var builder = WebApplication.CreateBuilder(args); // This method creates a new instance of the WebApplicationBuilder class.

// Add services to the container.
builder.Services.AddControllers(); // This method adds services to the container. These services are available to the app and its components through dependency injection.
builder.Services.AddDbContext<TodoContext>(opt => opt.UseInMemoryDatabase("TodoList")); // This method adds a database context to the container. The database context is used in each of the CRUD methods in the controller. The database context is registered with a service lifetime of scoped, which means that the context is created once per client request (connection).
builder.Services.AddOpenApi(); // This method adds the OpenAPI generator to the container. The OpenAPI generator is used to generate an OpenAPI document for the app's API.
builder.Services.AddEndpointsApiExplorer(); // This method adds the API explorer to the container. The API explorer is used to explore the app's API endpoints.

var app = builder.Build(); // This method builds the app and configures it to use the services that were added to the container.

if (app.Environment.IsDevelopment())
{
    app.MapOpenApi(); // This method adds the OpenAPI middleware to the app's request pipeline.
    app.UseSwaggerUi(options => // This method configures the Swagger UI options.
    {
        options.DocumentPath = "/openapi/v1.json";
    });
}

app.UseHttpsRedirection(); // This method configures the app to redirect HTTP requests to HTTPS.
app.UseAuthorization(); // This method configures the app to use authorization.
app.MapControllers(); // This method adds the routing middleware to the app's request pipeline.

app.Run(); // This method runs the app.
```

</TabItem>

</Tabs>

- Run the app

```bash
dotnet watch run --launch-profile https
```

## Adding Swagger

```bash
dotnet add package NSwag.AspNetCore
```

```csharp title="Program.cs"
var app = builder.Build();

builder.Services.AddOpenApi();

if (app.Environment.IsDevelopment())
{
    app.MapOpenApi();
    // highlight-start
    app.UseSwaggerUi(options =>
    {
        options.DocumentPath = "/openapi/v1.json";
    });
    // highlight-end
}
```

```bash
localhost:7236/swagger/index.html?url=/openapi/v1.json
```
