---
sidebar_label: "Widgets"
sidebar_position: 2
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Flutter Widgets

Flutter widgets are the basic building blocks of a Flutter app's user interface. Each widget is an immutable declaration of part of the user interface.

## Stateless Widget Example

A stateless widget is a widget that does not require mutable state. It is useful for parts of the user interface that do not change dynamically. The widget is rendered once with the given configuration and does not rebuild unless the input configuration changes.

```dart
import 'package:flutter/material.dart';

class HelloWorld extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Text('Hello, world!'),
    );
  }
}
```

### Stateless Widget with a Widget Argument

Here is an example of a stateless widget that takes another widget as an argument in its constructor. This is a common pattern for creating reusable layout components.

```dart
import 'package:flutter/material.dart';

class CustomCard extends StatelessWidget {
  final Widget child;

  const CustomCard({Key? key, required this.child}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16.0),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8.0),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: child,
    );
  }
}
```

To use this `CustomCard` widget, you would pass another widget to its `child` property:

```dart
CustomCard(
  child: Text('This is inside the card'),
)
```

## Stateful Widget Example

A stateful widget is a widget that has mutable state. It is useful for parts of the user interface that can change dynamically. When the internal state of the widget changes, the widget is rebuilt to reflect the new state.

<p>We use two classes for a StatefulWidget to separate the immutable widget configuration from the mutable state. The `Counter` class is the widget, and it's immutable. The `_CounterState` class is the state, and it can change over time. This separation allows Flutter to be more efficient by reusing the widget object even when the state changes.</p>

```dart
import 'package:flutter/material.dart';

class Counter extends StatefulWidget {
  const Counter({super.key});

  @override
  State<Counter> createState() => _CounterState();
}

class _CounterState extends State<Counter> {
  int _counter = 0;

  void _increment() {
    setState(() {
      _counter++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      children: <Widget>[
        ElevatedButton(
          onPressed: _increment,
          child: Text('Increment'),
        ),
        SizedBox(width: 16),
        Text('Count: $_counter'),
      ],
    );
  }
}
```

### Stateful Widget with an Argument

Here is an example of a stateful widget that takes an argument in its constructor. The argument is passed from the widget to the state.

```dart
import 'package:flutter/material.dart';

class Counter extends StatefulWidget {
  const Counter({super.key, required this.initialValue});

  final int initialValue;

  @override
  State<Counter> createState() => _CounterState();
}

class _CounterState extends State<Counter> {
  late int _counter;

  @override
  void initState() {
    super.initState();
    _counter = widget.initialValue;
  }

  void _increment() {
    setState(() {
      _counter++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      children: <Widget>[
        ElevatedButton(
          onPressed: _increment,
          child: Text('Increment'),
        ),
        SizedBox(width: 16),
        Text('Count: $_counter'),
      ],
    );
  }
}
```

To use this widget, you would pass the `initialValue` to its constructor:

```dart
Counter(initialValue: 5)
```



## Widget with Multiple Constructors

Here is an example of a widget that has multiple constructors.

```dart
import 'package:flutter/material.dart';

class MyButton extends StatelessWidget {
  final String text;
  final Color color;

  const MyButton({super.key, required this.text, required this.color});

  const MyButton.primary({super.key, required this.text}) : color = Colors.blue;

  const MyButton.secondary({super.key, required this.text}) : color = Colors.grey;

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: () {},
      style: ElevatedButton.styleFrom(backgroundColor: color),
      child: Text(text),
    );
  }
}
```

To use this widget, you can call the appropriate constructor:

```dart
Column(
  children: [
    MyButton(text: 'Custom', color: Colors.red),
    MyButton.primary(text: 'Primary'),
    MyButton.secondary(text: 'Secondary'),
  ],
)
```

## Combining Widgets

You can build complex UIs by combining multiple widgets. Here's an example of a `Column` widget that holds two `Text` widgets.

```dart
import 'package:flutter/material.dart';

class SimpleLayout extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Combining Widgets'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            Text('Hello,'),
            Text('World!'),
          ],
        ),
      ),
    );
  }
}
```

## Images

To add assets like images to your Flutter application, you need to declare them in your `pubspec.yaml` file.

First, create an `assets` folder in the root of your project and add your images to it. For example, you can create a folder `assets/images` and add a file named `my_image.png`.

Then, open your `pubspec.yaml` file and add the following to the `flutter` section:

```yaml
flutter:
  assets:
    - assets/images/
```

This will make all the images in the `assets/images` folder available in your application.

### Using the Image

Once you have added the assets to your `pubspec.yaml` file, you can use them in your application using the `Image` widget in two ways:

1.  `Image(image: AssetImage('path/to/image.png'))`
2.  `Image.asset('path/to/image.png')`

Here is an example of how to use both:

```dart title="main.dart"
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      home: Scaffold(
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Image(image: AssetImage('assets/images/dice-1.png')),
              Image.asset('assets/images/dice-2.png'),
            ],
          ),
        ),
      ),
    );
  }
}
```



