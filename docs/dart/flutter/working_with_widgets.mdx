---
sidebar_label: "Working with Widgets"
sidebar_position: 3
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Working with Widgets

In Flutter, you'll often need to share state between widgets. One common pattern for this is called "lifting state up". This means that a parent widget manages the state and passes it down to its children. The children can then notify the parent when the state needs to change.

## Lifting State Up Example

Here's an example of how to lift state up to manage which screen is currently active. We'll have a parent widget that holds the state and two child widgets that represent the screens.

<Tabs>
  <TabItem value="main" label="main.dart">
    <p>The main file manages which screen to show based on the <code>_activeScreen</code> state.</p>
    ```dart title="main.dart"
    import 'package:flutter/material.dart';
    import './start_screen.dart';
    import './questions_screen.dart';

    class App extends StatefulWidget {
      const App({super.key});

      @override
      State<App> createState() => _AppState();
    }

    class _AppState extends State<App> {
      String _activeScreen = 'start-screen';

      void _switchScreen() {
        setState(() {
          _activeScreen = 'questions-screen';
        });
      }

      @override
      Widget build(BuildContext context) {
        return MaterialApp(
          home: Scaffold(
            body: Center(
              child: _activeScreen == 'start-screen'
                  ? StartScreen(_switchScreen)
                  : const QuestionsScreen(),
            ),
          ),
        );
      }
    }
    ```
  </TabItem>
  <TabItem value="start" label="start_screen.dart">
    <p>The start screen widget takes the <code>_switchScreen</code> function as an argument and calls it when the button is pressed.</p>
    ```dart title="start_screen.dart"
    import 'package:flutter/material.dart';

    class StartScreen extends StatelessWidget {
      const StartScreen(this.startQuiz, {super.key});

      final void Function() startQuiz;

      @override
      Widget build(BuildContext context) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text(
              'Learn Flutter the fun way!',
              style: TextStyle(
                color: Colors.white,
                fontSize: 24,
              ),
            ),
            const SizedBox(height: 30),
            OutlinedButton.icon(
              onPressed: startQuiz,
              style: OutlinedButton.styleFrom(
                foregroundColor: Colors.white,
              ),
              icon: const Icon(Icons.arrow_right_alt),
              label: const Text('Start Quiz'),
            )
          ],
        );
      }
    }
    ```
  </TabItem>
  <TabItem value="questions" label="questions_screen.dart">
    <p>The questions screen is a simple stateless widget that displays a message.</p>
    ```dart title="questions_screen.dart"
    import 'package:flutter/material.dart';

    class QuestionsScreen extends StatelessWidget {
      const QuestionsScreen({super.key});

      @override
      Widget build(BuildContext context) {
        return const Text('Questions Screen');
      }
    }
    ```
  </TabItem>
</Tabs>

In this example, the `App` widget holds the `_activeScreen` state. It passes the `_switchScreen` function to the `StartScreen` widget. When the button in `StartScreen` is pressed, it calls `_switchScreen`, which updates the state in the `App` widget, causing the UI to rebuild and show the `QuestionsScreen`.

## Creating Widgets from a List

Here's an example of how to create a list of widgets from a list of data.

<Tabs>
  <TabItem value="for-in" label="For-in loop">
    ```dart
    import 'package:flutter/material.dart';

    class NamesList extends StatelessWidget {
      const NamesList({super.key});

      @override
      Widget build(BuildContext context) {
        const names = ['Alice', 'Bob', 'Charlie'];

        return Column(
          children: [
            for (final name in names) Text(name),
          ],
        );
      }
    }
    ```
  </TabItem>
  <TabItem value="map" label=".map()">
    ```dart
    import 'package:flutter/material.dart';

    class NamesList extends StatelessWidget {
      const NamesList({super.key});

      @override
      Widget build(BuildContext context) {
        const names = ['Alice', 'Bob', 'Charlie'];

        return Column(
          children: [
            // The spread operator (...) is used to insert all the elements 
            // from an iterable into a list.
            // highlight-next-line
            ...names.map((name) => Text(name)),
          ],
        );
      }
    }
    ```
  </TabItem>
</Tabs>

## Passing a Function as an Argument to a Stateful Widget

Here's an example of how to pass a function as an argument to a stateful widget.

<Tabs>
  <TabItem value="main" label="main.dart">
    ```dart title="main.dart"
    import 'package:flutter/material.dart';
    import './my_button.dart';

    class App extends StatelessWidget {
      const App({super.key});

      // highlight-next-line
      void _myFunction() {
        print('Button pressed!');
      }

      @override
      Widget build(BuildContext context) {
        return MaterialApp(
          home: Scaffold(
            body: Center(
              // highlight-next-line
              child: MyButton(onPressed: _myFunction),
            ),
          ),
        );
      }
    }
    ```
  </TabItem>
  <TabItem value="my_button" label="my_button.dart">
    ```dart title="my_button.dart"
    import 'package:flutter/material.dart';

    class MyButton extends StatefulWidget {
      const MyButton({super.key, required this.onPressed});

      // highlight-next-line
      final void Function() onPressed;

      @override
      State<MyButton> createState() => _MyButtonState();
    }

    class _MyButtonState extends State<MyButton> {
      @override
      Widget build(BuildContext context) {
        return ElevatedButton(
          // highlight-next-line
          onPressed: widget.onPressed,
          child: const Text('Press Me'),
        );
      }
    }
    ```
  </TabItem>
</Tabs>

## ListView in a Column

When embedding a `ListView` inside a `Column` (or `Row`), the `ListView` needs constrained dimensions. Without explicit constraints, a `ListView` will try to take up infinite space, leading to a rendering error. You can use `Expanded` or `SizedBox` to provide these constraints.

### Using Expanded

`Expanded` is useful when you want the `ListView` to take up all the remaining available space within the `Column`.

```dart
import 'package:flutter/material.dart';

class ListViewInColumnExpanded extends StatelessWidget {
  const ListViewInColumnExpanded({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('ListView in Column (Expanded)')),
      body: Column(
        children: [
          const Padding(
            padding: EdgeInsets.all(8.0),
            child: Text(
              'Header Content',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
          ),
          // highlight-next-line
          Expanded(
            child: ListView.builder(
              itemCount: 50,
              itemBuilder: (context, index) {
                return ListTile(title: Text('Item $index'));
              },
            ),
          ),
          const Padding(
            padding: EdgeInsets.all(8.0),
            child: Text('Footer Content'),
          ),
        ],
      ),
    );
  }
}
```

### Using SizedBox

`SizedBox` is useful when you want to give the `ListView` a fixed height (or width in a `Row`).

```dart
import 'package:flutter/material.dart';

class ListViewInColumnSizedBox extends StatelessWidget {
  const ListViewInColumnSizedBox({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('ListView in Column (SizedBox)')),
      body: Column(
        children: [
          const Padding(
            padding: EdgeInsets.all(8.0),
            child: Text(
              'Header Content',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
          ),
          // highlight-next-line
          SizedBox(
            height: 200, // Fixed height for the ListView
            child: ListView.builder(
              itemCount: 50,
              itemBuilder: (context, index) {
                return ListTile(title: Text('Item $index'));
              },
            ),
          ),
          const Padding(
            padding: EdgeInsets.all(8.0),
            child: Text('Footer Content'),
          ),
        ],
      ),
    );
  }
}
```

## Show Modal Bottom Sheet

A modal bottom sheet is a panel that slides up from the bottom of the screen to reveal more content. It's a great way to display extra options or information without cluttering the main screen.

Here's how to implement a `showModalBottomSheet`:

```dart
import 'package:flutter/material.dart';

class MyModalBottomSheet extends StatelessWidget {
  const MyModalBottomSheet({super.key});

  void _showSheet(BuildContext context) {
    showModalBottomSheet(
      context: context,
      useSafeArea: true, // Ensures content doesn't overlap system UI (notches, status bar)
      builder: (BuildContext context) {
        return const SizedBox(
          height: 200,
          child: Center(
            child: Text('This is a modal bottom sheet'),
          ),
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Modal Bottom Sheet Demo'),
      ),
      body: Center(
        child: ElevatedButton(
          onPressed: () => _showSheet(context),
          child: const Text('Show Sheet'),
        ),
      ),
    );
  }
}
```

## Getting User Input

To get user input, you can use a `TextField` widget and a `TextEditingController`. The controller allows you to read the text that the user has entered.

Here's an example of how to get user input and print it to the console:

```dart
import 'package:flutter/material.dart';

class UserInput extends StatefulWidget {
  const UserInput({super.key});

  @override
  State<UserInput> createState() => _UserInputState();
}

class _UserInputState extends State<UserInput> {
  // Create a text controller and use it to retrieve the current value
  // of the TextField.
  // highlight-next-line
  final _textController = TextEditingController();

  @override
  void dispose() {
    // Clean up the controller when the widget is disposed.
    _textController.dispose();
    super.dispose();
  }

  void _printInputValue() {
    // highlight-next-line
    print('User input: ${_textController.text}');
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        children: [
          TextField(
            // highlight-next-line
            controller: _textController,
            decoration: const InputDecoration(
              border: OutlineInputBorder(),
              labelText: 'Enter your text',
            ),
            // highlight-next-line
            keyboardType: TextInputType.text,
          ),
          const SizedBox(height: 20),
          ElevatedButton(
            onPressed: _printInputValue,
            child: const Text('Print Input'),
          ),
        ],
      ),
    );
  }
}
```

## Showing a Date Picker

To show a date picker, you can use the `showDatePicker` function. This function returns a `Future`, so it's best to use it with `async/await`.

Here's an example of how to show a date picker and display the selected date:

```dart
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

class MyDatePicker extends StatefulWidget {
  const MyDatePicker({super.key});

  @override
  State<MyDatePicker> createState() => _MyDatePickerState();
}

class _MyDatePickerState extends State<MyDatePicker> {
  DateTime? _selectedDate;

  // highlight-next-line
  Future<void> _selectDate(BuildContext context) async {
    // highlight-next-line
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate ?? DateTime.now(),
      firstDate: DateTime(2000),
      lastDate: DateTime(2101),
    );
    if (picked != null && picked != _selectedDate) {
      setState(() {
        _selectedDate = picked;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: <Widget>[
        Text(
          _selectedDate == null
              ? 'No date selected!'
              // Format the date
              : 'Selected date: ${DateFormat.yMd().format(_selectedDate!)}',
        ),
        const SizedBox(height: 20.0),
        ElevatedButton(
          onPressed: () => _selectDate(context),
          child: const Text('Select date'),
        ),
      ],
    );
  }
}
```

## Show Alert Dialog

An `AlertDialog` is a pop-up dialog that informs the user about situations that require acknowledgment. It can have an optional title, optional content, and an optional list of actions.

Here's how to show an `AlertDialog`:

```dart
import 'package:flutter/material.dart';

class MyAlertDialog extends StatelessWidget {
  const MyAlertDialog({super.key});

  Future<void> _showMyDialog(BuildContext context) async {
    return showDialog<void>(
      context: context,
      barrierDismissible: false, // user must tap button!
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('AlertDialog Title'),
          content: const SingleChildScrollView(
            child: ListBody(
              children: <Widget>[
                Text('This is a demo alert dialog.'),
                Text('Would you like to approve of this message?'),
              ],
            ),
          ),
          actions: <Widget>[
            TextButton(
              child: const Text('Approve'),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
          ],
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    // This button should be placed within a Scaffold body.
    return ElevatedButton(
      onPressed: () => _showMyDialog(context),
      child: const Text('Show Dialog'),
    );
  }
}
```

## Removing List Items with Dismissible

The `Dismissible` widget allows you to swipe to dismiss a widget from the screen. This is commonly used for deleting items from a list.

Here's an example of how to use `Dismissible` to remove items from a list of strings:

```dart
import 'package:flutter/material.dart';

class DismissibleList extends StatefulWidget {
  const DismissibleList({super.key});

  @override
  State<DismissibleList> createState() => _DismissibleListState();
}

class _DismissibleListState extends State<DismissibleList> {
  final List<String> _items = ['Item 1', 'Item 2', 'Item 3'];

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      itemCount: _items.length,
      itemBuilder: (context, index) {
        final String item = _items[index];
        // highlight-start
        return Dismissible(
          key: Key(item),
          onDismissed: (direction) {
            setState(() {
              _items.removeAt(index);
            });
          },
          background: Container(color: Colors.red),
          child: ListTile(
            title: Text(item),
          ),
        );
        // highlight-end
      },
    );
  }
}
```

## Showing a SnackBar

A `SnackBar` is a lightweight message that briefly appears at the bottom of the screen. It can be used to provide feedback to the user. A `SnackBar` can also have an optional action, such as an "Undo" button. To prevent `SnackBar`s from queuing up, you can use `ScaffoldMessenger.of(context).clearSnackBars()` before showing a new one.

Here's how to show a basic `SnackBar` with custom content and duration:

```dart
import 'package:flutter/material.dart';

class SnackBarExample extends StatelessWidget {
  const SnackBarExample({super.key});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: ElevatedButton(
        onPressed: () {
          // highlight-start
          final snackBar = SnackBar(
            content: const Text('This is a SnackBar!'),
            duration: const Duration(seconds: 3),
          );
          ScaffoldMessenger.of(context).showSnackBar(snackBar);
          // highlight-end
        },
        child: const Text('Show SnackBar'),
      ),
    );
  }
}
```

## Adding a tap effect

`InkWell` is a material design widget that creates a rectangular area that responds to touch with an ink splash effect. It's perfect for adding tap interactions to any widget with visual feedback.

Here's a simple example showing `onTap` and `splashColor`:

```dart
import 'package:flutter/material.dart';

class InkWellExample extends StatelessWidget {
  const InkWellExample({super.key});

  @override
  Widget build(BuildContext context) {
    return InkWell(
      // highlight-next-line
      onTap: () {
        print('Container tapped!');
      },
      // highlight-next-line
      splashColor: Colors.blue.withOpacity(0.3),
      child: Container(
        width: 200,
        height: 100,
        decoration: BoxDecoration(
          color: Colors.grey[200],
          border: Border.all(color: Colors.grey),
          borderRadius: BorderRadius.circular(8),
        ),
        child: const Center(
          child: Text(
            'Tap me!',
            style: TextStyle(fontSize: 18),
          ),
        ),
      ),
    );
  }
}
```

Key properties:
- `onTap` - Called when the user taps the widget
- `splashColor` - Color of the ink splash effect when tapped
- `borderRadius` - Can be added to match the child's border radius
- `child` - The widget to wrap with tap functionality

## Stacking Widgets

The `Stack` widget allows you to layer widgets on top of each other. Widgets are stacked in the order they appear in the children list, with the last widget being on top.

Here's a simple example showing how to overlay text on an image:

```dart
import 'package:flutter/material.dart';

class StackExample extends StatelessWidget {
  const StackExample({super.key});

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        // Background widget (bottom layer)
        Container(
          width: 300,
          height: 200,
          decoration: BoxDecoration(
            color: Colors.blue,
            borderRadius: BorderRadius.circular(12),
          ),
        ),
        // Positioned text (top layer)
        // highlight-next-line
        Positioned(
          bottom: 16,
          left: 16,
          right: 16,
          child: Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: Colors.black.withOpacity(0.7),
              borderRadius: BorderRadius.circular(8),
            ),
            child: const Text(
              'Overlay Text',
              style: TextStyle(
                color: Colors.white,
                fontSize: 16,
                fontWeight: FontWeight.bold,
              ),
              textAlign: TextAlign.center,
            ),
          ),
        ),
      ],
    );
  }
}
```

### Positioning Options

You can use `Positioned` widget to control exactly where widgets appear:

```dart
Stack(
  children: [
    Container(width: 200, height: 200, color: Colors.grey),
    // Top-left corner
    Positioned(
      top: 10,
      left: 10,
      child: Container(width: 50, height: 50, color: Colors.red),
    ),
    // Bottom-right corner
    Positioned(
      bottom: 10,
      right: 10,
      child: Container(width: 50, height: 50, color: Colors.green),
    ),
    // Centered
    Positioned.fill(
      child: Center(
        child: Container(width: 30, height: 30, color: Colors.yellow),
      ),
    ),
  ],
)
```

Key properties:
- `children` - List of widgets to stack (first = bottom, last = top)
- `Positioned` - Controls exact placement within the stack
- `Positioned.fill` - Makes a widget fill the entire stack area
- `alignment` - Default alignment for non-positioned children

## Images

To add assets like images to your Flutter application, you need to declare them in your `pubspec.yaml` file.

First, create an `assets` folder in the root of your project and add your images to it. For example, you can create a folder `assets/images` and add a file named `my_image.png`.

Then, open your `pubspec.yaml` file and add the following to the `flutter` section:

```yaml
flutter:
  assets:
    - assets/images/
```

This will make all the images in the `assets/images` folder available in your application.

### Using the Image

Once you have added the assets to your `pubspec.yaml` file, you can use them in your application using the `Image` widget in two ways:

1.  `Image(image: AssetImage('path/to/image.png'))`
2.  `Image.asset('path/to/image.png')`

Here is an example of how to use both:

```dart title="main.dart"
import 'package:flutter/material.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      home: Scaffold(
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Image(image: AssetImage('assets/images/dice-1.png')),
              Image.asset('assets/images/dice-2.png'),
            ],
          ),
        ),
      ),
    );
  }
}
```

### Loading Images from the Web

You can also load images directly from the internet using `Image.network()`. This is useful for displaying profile pictures, product images, or any dynamic content from a web API.

```dart title="web_image_example.dart"
import 'package:flutter/material.dart';

class WebImageExample extends StatelessWidget {
  const WebImageExample({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Web Images')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            // highlight-next-line
            Image.network(
              'https://picsum.photos/200/300',
              width: 200,
              height: 300,
              // Optional: Show a loading indicator while image loads
              loadingBuilder: (context, child, loadingProgress) {
                if (loadingProgress == null) return child;
                return const CircularProgressIndicator();
              },
              // Optional: Show an error icon if image fails to load
              errorBuilder: (context, error, stackTrace) {
                return const Icon(Icons.error, size: 50);
              },
            ),
          ],
        ),
      ),
    );
  }
}
```
